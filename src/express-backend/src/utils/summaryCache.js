// ============================================================================
// REDIS SUMMARY CACHE GENERATOR
// Pre-computes dashboard summary data to avoid expensive pattern scans
// ============================================================================

/**
 * Generates and caches a comprehensive summary of Redis data
 * This replaces expensive real-time pattern scanning in the dashboard
 */
async function generateAndCacheSummary(redisClient, year = '2025') {
  console.log(`üîÑ Generating summary cache for year ${year}...`);
  
  try {
    const startTime = Date.now();
    
    // Get all the key patterns we need (this is expensive but done once)
    // NOTE: Deliberately excluding splits to keep dashboard cache lightweight
    const [
      playerSeasonKeys,
      teamSeasonKeys,
      playerGameKeys,
      teamGameKeys
    ] = await Promise.all([
      redisClient.keys(`player:*-${year}:season`),
      redisClient.keys(`team:*:${year}:season`),
      redisClient.keys(`player:*-${year}:????-??-??-*`),
      redisClient.keys(`team:*:${year}:????-??-??-*`)
    ]);
    
    // Calculate unique dates and games
    const uniqueDates = new Set();
    
    playerGameKeys.forEach(key => {
      const parts = key.split(':');
      const date = parts[parts.length - 1];
      if (date && date.match(/^\d{4}-\d{2}-\d{2}$/)) {
        uniqueDates.add(date);
      }
    });
    
    // Calculate actual games (each game has 2 team entries)
    const actualGames = Math.round(teamGameKeys.length / 2);
    
    // Build the comprehensive summary (excluding splits for performance)
    const summary = {
      year,
      generatedAt: new Date().toISOString(),
      performance: {
        generationTimeMs: Date.now() - startTime,
        totalKeys: playerSeasonKeys.length + teamSeasonKeys.length + playerGameKeys.length + teamGameKeys.length
      },
      summary: {
        totalPlayers: playerSeasonKeys.length,
        totalTeams: teamSeasonKeys.length,
        totalPlayerGames: playerGameKeys.length,
        totalTeamGames: teamGameKeys.length,
        totalGameDates: uniqueDates.size,
        totalGames: actualGames,
        averagePlayersPerGame: actualGames > 0 ? Math.round(playerGameKeys.length / actualGames) : 0,
        averageGamesPerDay: uniqueDates.size > 0 ? Math.round(actualGames / uniqueDates.size) : 0
      },
      dataStructure: {
        playerSeasonStats: playerSeasonKeys.length,
        teamSeasonStats: teamSeasonKeys.length,
        playerGameStats: playerGameKeys.length,
        teamGameStats: teamGameKeys.length
      },
      metadata: {
        dataTypes: [
          'Season Statistics',
          'Game-by-Game Data'
        ],
        keyPatterns: {
          players: `player:TEAM-PLAYER_NAME-${year}:season|date`,
          teams: `team:TEAM:${year}:season|date`
        },
        note: 'Split analytics excluded from dashboard cache for performance - loaded on-demand via /api/v2/splits/*'
      }
    };
    
    // Define cache key and store the summary
    const cacheKey = `summary:dashboard:${year}`;
    
    // Store permanently (dashboard key should not expire)
    await redisClient.set(cacheKey, JSON.stringify(summary));
    
    const endTime = Date.now();
    console.log(`‚úÖ Summary cached in ${endTime - startTime}ms`);
    console.log(`üìä Total keys analyzed: ${summary.performance.totalKeys.toLocaleString()}`);
    console.log(`üîë Cache key: ${cacheKey}`);
    console.log(`‚ôæÔ∏è  Dashboard cache is permanent - no expiration`);
    console.log(`‚ö° Dashboard cache optimized - splits excluded for performance`);    return summary;
    
  } catch (error) {
    console.error('‚ùå Error generating summary cache:', error);
    throw error;
  }
}

/**
 * Gets cached summary - READ ONLY (no auto-generation)
 * Cache is only created by pullBoxscoreRedis.cjs script
 */
async function getCachedSummary(redisClient, year = '2025') {
  // Force exact key match with script
  const cacheKey = `summary:dashboard:2025`;
  
  try {
    console.log(`üîç Looking for cached summary with key: ${cacheKey}`);
    const cachedSummary = await redisClient.get(cacheKey);
    
    if (cachedSummary) {
      console.log(`‚úÖ Using cached summary for 2025`);
      return JSON.parse(cachedSummary);
    } else {
      console.log(`‚ö†Ô∏è  No cached summary found - run pullBoxscoreRedis.cjs to generate`);
      // Return minimal fallback instead of auto-generating
      return {
        year: '2025',
        summary: {
          totalPlayers: 0,
          totalTeams: 0,
          totalGames: 0,
          message: 'Dashboard cache not found - run data collection script to generate'
        },
        metadata: {
          note: 'Cache is only generated by pullBoxscoreRedis.cjs script'
        }
      };
    }
  } catch (error) {
    console.error('‚ùå Error getting cached summary:', error);
    // Fallback to minimal summary
    return {
      year: '2025',
      error: error.message,
      summary: {
        totalPlayers: 0,
        totalTeams: 0,
        totalGames: 0,
        message: 'Summary temporarily unavailable'
      }
    };
  }
}

module.exports = {
  generateAndCacheSummary,
  getCachedSummary
};
