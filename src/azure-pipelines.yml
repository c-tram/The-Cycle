# Docker
# Build and push an image to Azure Container Registry
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker

trigger:
- main

resources:
- repo: self

variables:
  # Service connection for Azure Container Registry (set in Azure DevOps UI)
  dockerRegistryServiceConnection: $(DOCKER_REGISTRY_SERVICE_CONNECTION)
  # Name of the image repository
  imageRepository: $(IMAGE_REPOSITORY)
  # Container registry URL
  containerRegistry: $(CONTAINER_REGISTRY)
  # Path to the Dockerfile (corrected path)
  dockerfilePath: $(Build.SourcesDirectory)/Dockerfile
  # Tag for the image
  tag: $(IMAGE_TAG)
  # Redis configuration
  redisName: '$(REDIS_NAME)'
  redisResourceGroup: '$(RESOURCE_GROUP_NAME)'
  redisLocation: '$(LOCATION)'
  redisSku: '$(SKU)'
  redisFamily: '$(FAMILY)'
  redisCapacity: '$(CAPACITY)'

  # Agent VM image name
  vmImageName: 'ubuntu-latest'

stages:
- stage: Infrastructure
  displayName: Setup Infrastructure
  jobs:
  - job: SetupRedis
    displayName: Setup Redis Cache
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: AzureCLI@2
      displayName: 'Create or update Redis Cache'
      inputs:
        azureSubscription: $(AZURE_SUBSCRIPTION)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Check if Redis cache exists
          if az redis show --name $(redisName) --resource-group $(redisResourceGroup) &> /dev/null; then
            echo "Redis cache $(redisName) already exists."
          else
            echo "Creating Redis cache $(redisName)..."
            az redis create \
              --name $(redisName) \
              --resource-group $(redisResourceGroup) \
              --location $(redisLocation) \
              --sku $(redisSku) \
              --vm-size "$(redisFamily)$(redisCapacity)" \
              --enable-non-ssl-port false \
              --minimum-tls-version 1.2 \
              --redis-configuration "aad-enabled=true,maxclients=1000,maxmemory-reserved=125,maxfragmentationmemory-reserved=125,maxmemory-delta=125"
          fi
          
          # Get Redis connection information
          REDIS_HOST=$(az redis show --name $(redisName) --resource-group $(redisResourceGroup) --query hostName -o tsv)
          REDIS_PORT=$(az redis show --name $(redisName) --resource-group $(redisResourceGroup) --query sslPort -o tsv)
          
          # Check if key authentication is disabled (AAD auth is used)
          ACCESS_KEY_DISABLED=$(az redis show --name $(redisName) --resource-group $(redisResourceGroup) --query properties.disableAccessKeyAuthentication -o tsv)
          AAD_ENABLED=$(az redis show --name $(redisName) --resource-group $(redisResourceGroup) --query "properties.redisConfiguration.aad-enabled" -o tsv)
          
          if [[ "$ACCESS_KEY_DISABLED" == "true" && "$AAD_ENABLED" == "true" ]]; then
            echo "Azure AD authentication is enabled for Redis cache $(redisName)"
            REDIS_AUTH_MODE="aad"
            # For AAD auth, we'll use managed identity
            REDIS_PASSWORD=""
          else
            echo "Standard key authentication is used for Redis cache $(redisName)"
            REDIS_AUTH_MODE="key"
            # Get the primary access key
            REDIS_PASSWORD=$(az redis list-keys --name $(redisName) --resource-group $(redisResourceGroup) --query primaryKey -o tsv || echo "")
          fi
          
          # Debug: Print the values we retrieved
          echo "üîç Debug: Retrieved Redis configuration:"
          echo "  REDIS_HOST: '$REDIS_HOST'"
          echo "  REDIS_PORT: '$REDIS_PORT'"
          echo "  REDIS_PASSWORD: $(if [[ -n '$REDIS_PASSWORD' ]]; then echo '[SET]'; else echo '[NOT SET]'; fi)"
          echo "  REDIS_AUTH_MODE: '$REDIS_AUTH_MODE'"
          
          # Validate required values are not empty
          if [[ -z "$REDIS_HOST" ]]; then
            echo "‚ùå ERROR: REDIS_HOST is empty!"
            exit 1
          fi
          
          if [[ -z "$REDIS_PORT" ]]; then
            echo "‚ùå ERROR: REDIS_PORT is empty!"
            exit 1
          fi
          
          # Set pipeline variables for later use
          echo "##vso[task.setvariable variable=REDIS_HOST;isOutput=true]$REDIS_HOST"
          echo "##vso[task.setvariable variable=REDIS_PORT;isOutput=true]$REDIS_PORT"
          echo "##vso[task.setvariable variable=REDIS_PASSWORD;isOutput=true]$REDIS_PASSWORD"
          echo "##vso[task.setvariable variable=REDIS_AUTH_MODE;isOutput=true]$REDIS_AUTH_MODE"
        addSpnToEnvironment: true
      name: redisInfo

- stage: Build
  displayName: Build and push stage
  dependsOn: Infrastructure
  jobs:
  - job: BuildApp
    displayName: Build Combined Application
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: AzureCLI@2
      displayName: 'Login to ACR and build/push image'
      inputs:
        azureSubscription: $(AZURE_SUBSCRIPTION)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Extract registry name from full URL if needed
          REGISTRY_NAME=$(echo "$(containerRegistry)" | sed 's/.azurecr.io//')
          FULL_REGISTRY_URL="$REGISTRY_NAME.azurecr.io"
          
          echo "Registry name: $REGISTRY_NAME"
          echo "Full registry URL: $FULL_REGISTRY_URL"
          
          # Login to Azure Container Registry
          az acr login --name $REGISTRY_NAME
          
          # Build and tag the image
          docker build -f $(Build.SourcesDirectory)/Dockerfile.combined \
            --build-arg NODE_ENV=production \
            -t $FULL_REGISTRY_URL/$(imageRepository):$(tag) \
            $(Build.SourcesDirectory)
          
          # Push the image
          docker push $FULL_REGISTRY_URL/$(imageRepository):$(tag)
          
          echo "Successfully built and pushed $FULL_REGISTRY_URL/$(imageRepository):$(tag)"

- stage: Deploy
  displayName: Deploy to production slot
  dependsOn: 
    - Infrastructure
    - Build
  condition: and(succeeded('Infrastructure'), succeeded('Build'))
  jobs:
  - job: DeployApp
    displayName: Deploy App to production slot
    pool:
      vmImage: $(vmImageName)
    variables:
      REDIS_HOST: $[stageDependencies.Infrastructure.SetupRedis.outputs['redisInfo.REDIS_HOST']]
      REDIS_PORT: $[stageDependencies.Infrastructure.SetupRedis.outputs['redisInfo.REDIS_PORT']]
      REDIS_PASSWORD: $[stageDependencies.Infrastructure.SetupRedis.outputs['redisInfo.REDIS_PASSWORD']]
      REDIS_AUTH_MODE: $[stageDependencies.Infrastructure.SetupRedis.outputs['redisInfo.REDIS_AUTH_MODE']]
    steps:
    - task: AzureCLI@2
      displayName: 'Debug Redis Configuration'
      inputs:
        azureSubscription: $(AZURE_SUBSCRIPTION)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "üîç Debug: Checking Redis variables..."
          echo "REDIS_HOST: '$(REDIS_HOST)'"
          echo "REDIS_PORT: '$(REDIS_PORT)'"
          echo "REDIS_PASSWORD: $(if [[ -n '$(REDIS_PASSWORD)' ]]; then echo '[SET]'; else echo '[NOT SET]'; fi)"
          echo "REDIS_AUTH_MODE: '$(REDIS_AUTH_MODE)'"
          
          # Fail if critical variables are empty
          if [[ -z "$(REDIS_HOST)" ]]; then
            echo "‚ùå ERROR: REDIS_HOST is empty!"
            exit 1
          fi
          
          if [[ -z "$(REDIS_PORT)" ]]; then
            echo "‚ùå ERROR: REDIS_PORT is empty!"
            exit 1
          fi
          
          echo "‚úÖ Redis variables look good"
          
    - task: AzureAppServiceSettings@1
      displayName: 'Configure App Service Settings'
      inputs:
        azureSubscription: $(AZURE_SUBSCRIPTION)
        appName: TheCycle
        appSettings: |
          [
            {"name": "REDIS_HOST", "value": "$(REDIS_HOST)", "slotSetting": false},
            {"name": "REDIS_PORT", "value": "$(REDIS_PORT)", "slotSetting": false},
            {"name": "REDIS_PASSWORD", "value": "$(REDIS_PASSWORD)", "slotSetting": false},
            {"name": "REDIS_AUTH_MODE", "value": "$(REDIS_AUTH_MODE)", "slotSetting": false},
            {"name": "REDIS_TLS", "value": "true", "slotSetting": false},
            {"name": "NODE_ENV", "value": "production", "slotSetting": false},
            {"name": "WEBSITES_PORT", "value": "80", "slotSetting": false},
            {"name": "REACT_APP_API_URL", "value": "/api", "slotSetting": false}
          ]
        
    - task: AzureCLI@2
      displayName: 'Wait for App Settings to Apply'
      inputs:
        azureSubscription: $(AZURE_SUBSCRIPTION)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "‚è≥ Waiting 30 seconds for app settings to apply..."
          sleep 30
          echo "‚úÖ App settings should now be applied"
        
    - task: AzureWebAppContainer@1
      displayName: Deploy single container app
      inputs:
        azureSubscription: $(AZURE_SUBSCRIPTION)
        appName: TheCycle
        imageName: $(containerRegistry)/$(imageRepository):$(tag)
        
    - task: AzureCLI@2
      displayName: 'Restart App Service and check status'
      inputs:
        azureSubscription: $(AZURE_SUBSCRIPTION)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Restarting App Service..."
          az webapp restart --name TheCycle --resource-group Main
          
          echo "Waiting for restart and application initialization..."
          sleep 60
          
          echo "Checking App Service status..."
          az webapp show --name TheCycle --resource-group Main --query "state" -o tsv
          
          echo "Getting App Service URL..."
          URL=$(az webapp show --name TheCycle --resource-group Main --query "defaultHostName" -o tsv)
          echo "App URL: https://$URL"
          
          echo "Testing API health endpoint..."
          sleep 30
          curl -f "https://$URL/api/health" || echo "Health check failed - app may still be starting"
